# 二叉树

## [tree_edge.cpp](tree_edge.cpp) 打印数的边界
原题的关于第一种树边界打印的解法存在问题的。例如如下结构的树的打印就不符合要求。
```
       v3v
                   v8v
             ^6^
                   ^7^
  1
             v5v
       ^2^
             ^4^
1 2 4 7 |5 |8 6 3
```

## [3-btree_traverse.cpp](3-btree_traverse.cpp)树的非递归遍历
通用套路：栈。元素出栈时打印。每次处理栈顶元素，判断左右子树是否已经打印。
1. 先序遍历。栈顶元素的左右子树肯定是没有打印的，因为按照先序遍历的定义，只有元素出栈打印时才把左右孩子进栈，然后再去打印左右子树。参考函数`preorder_traverse_norecur`。
2. 中序遍历。栈顶元素的左子树可能已经打印，也可能没有打印。栈顶元素的右子树肯定没有打印。关键点在于判单左子树是否已经打印，要做到这一点不难，判断最近进栈的元素是否时栈顶元素即可，是则左子树肯定没有打印，否的话左子树已经打印完毕。参考函数`inorder_traverse_norecur2`。
3. 后序遍历。栈顶元素的左右孩子都有可能打印，或者没有打印。关键点在如何判断是否已经打印。左子树是否打印根据最近进栈的元素是否是栈顶节点判断。右子树是否打印根据最近打印的节点是否是栈顶元素的右孩子判断。参考函数`postorder_traverse_norecur2`。

